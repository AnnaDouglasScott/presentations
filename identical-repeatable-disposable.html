---
layout: reveal
title: Identical, Repeatable, Disposable
author: Sam Pikesley
twitter: pikesley
description: Test-Driven Infrastructure with Cucumber-chef
---

{% include odi_logo.html %}
{% include standard_title.html %}

<section id="who_am_i">
    <aside class="notes">
        <p>
            Hello, I'm Sam from the ODI and I'm here to talk to you about Test-Driven Infrastructure with Cucumber-chef.
            Some of this will of necessity be a little hand-wavy, and it may seem to weave around a little because we're
            going to cover a lot of ground, but stay with me and I hope it will all come together and make sense by the
            end
        </p>

        <p>
            My job title is DevOps Engineer, but DevOps isn't really a job. What I'm actually good at is automation,
            so my unofficial role is now Head Of Robots
        </p>
    </aside>
    <h1>Who am I?</h1>
    <ul>
        <li>
            DevOps Engineer at <a href="http://theodi.org/">the Open Data Institute</a>
        </li>
        <li>
            What is DevOps?
        </li>
        <li>
            It's about culture. It's not a deliverable
        </li>
        <li class="fragment">
            So I now prefer to be known as Head Of Robots
        </li>
    </ul>
</section>
<section id="behaviour_driven_development">
    <section>
        <aside class="notes">
            <p>
                So let's talk about behaviour-driven development
            </p>
            <p>
                Dan North (instigator of BDD) says: <em>"BDD is a second-generation, outside-in, pull-based,
                multiple-stakeholder, multiple-scale, high-automation, agile methodology. It describes a cycle of
                interactions with well-defined outputs, <strong>resulting in the delivery of working, tested software
                    that matters</strong>"</em>
            </p>
            <p>
                Now some of that text appears to me to be indistinguishable from advanced trolling, but the important
                thing there is that we come away with comprehensively-tested software that we actually want
            </p>
            <p>
                And we have some great BDD tools
            </p>
        </aside>
        <h1>Behaviour-Driven Development</h1>
        <ul>
            <li class="fragment">
                Dan North (instigator of BDD) says: <em>"BDD is a second-generation, outside-in, pull-based,
                multiple-stakeholder, multiple-scale, high-automation, agile methodology. It describes a cycle of
                interactions with well-defined outputs, <strong>resulting in the delivery of working, tested software
                    that matters</strong>"</em>
                (<a href="http://en.wikipedia.org/wiki/Behavior-driven_development#History">Wikipedia</a>)
            </li>
        </ul>
    </section>
    <section id="cucumber">
        <aside class="notes">
            <p>
                Cucumber is our weapon of choice for BDD. We can write our specifications in a very tightly-constrained
                dialect of English (or over 40 other spoken languages). This specification is executable. Let's see an
                example
            </p>
        </aside>
        <h1>Cucumber</h1>
        <h4><a href="http://cukes.info/">http://cukes.info/</a></h4>
        <ul>
            <li>
                Allows us to express requirements in something very close to plain English (using <a
                    href="https://github.com/cucumber/cucumber/wiki/Gherkin">Gherkin</a>)
            </li>
            <li>
                Executable Specification
            </li>
        </ul>
    </section>
    <section>
        <aside class="notes">
            <p>
                This is a part of a feature file from one of our projects. As you can see, this is entirely readable by
                normal people, and it captures our requirements in an extremely succinct way. Gherkin is designed to be
                usable by non-technical stakeholders
            </p>

            <p>
                So, we have our feature, now what do we do? Well we can run cucumber on this feature...
            </p>
        </aside>
        <h1>Write a feature</h1>
               <pre><code data-trim class="gherkin">Feature: Sign in to the member directory
  As a member, I need to sign in to the system to modify my account details

  Scenario: Successful signin
    Given that I have a membership number and password
    When I visit the sign in page
    And I enter my membership number and password
    And the password is correct
    When I click sign in
    Then I should have signed in successfully</code></pre>

        <small>
            From
            <a href="https://github.com/theodi/member-directory/blob/master/features/signin.feature">
                https://github.com/theodi/member-directory/blob/master/features/signin.feature
            </a>
        </small>
    </section>
    <section>
        <aside class="notes">
            <p>
                And it fails, of course, because at this point we have nothing. But note the helpful message, "express
                the regexp above with the code you wish you had". So let's see how we go about that
            </p>
        </aside>
        <h1>Watch it fail</h1>
        <pre><code data-trim class="gherkin">cucumber features/signin.feature -f progress
UUUUUU

1 scenario (1 undefined)
6 steps (6 undefined)
0m0.004s

You can implement step definitions for undefined steps with these snippets:

When(/^I enter my membership number and password$/) do
  pending # express the regexp above with the code you wish you had
end

Then(/^I should have signed in successfully$/) do
  pending # express the regexp above with the code you wish you had
end</code></pre>
    </section>
    <section>
        <aside class="notes">
            <p>
                So we write some step definitions. First we capture the text from the feature with the regular
                expression. Then we start driving out the code. Note that the outside-in nature of this approach forces
                us to think about our interfaces first - the text leads to the definition which shapes the underlying
                objects. This is powerful stuff
            </p>
            <p>
                These step defs represent the end of a process - when we're actually doing this for real, we proceed in
                small increments, running the tests at each stage. We follow the red - green - refactor cycle where we
                have a failing test, we write just enough code to make the test pass, then we refactor what we've
                written, but with the benefit of a safety net
            </p>
        </aside>
        <h1>Define the steps</h1>
        <p>
            Drive out the code required to make the tests pass
        </p>

        <pre><code data-trim class="step_definitions">Given /^that I have a membership number and password$/ do
  member = Member.create(
    :email => 'sam@foobar.com',
  )
  member.confirm!
  @membership_number = member.membership_number
  @password = 'p4ssw0rd'
end

When /^I enter my membership number and password$/ do
  fill_in('member_membership_number', :with => @membership_number)
end

Then /^I should have signed in successfully$/ do
  page.should have_content "Signed in successfully"
end</code></pre>

        <small>
            From
            <a href="https://github.com/theodi/member-directory/blob/master/features/step_definitions/signin_steps.rb">
                https://github.com/theodi/member-directory/blob/master/features/step_definitions/signin_steps.rb
            </a>
        </small>
    </section>
    <section>
        <aside class="notes">
            <p>
                I hope you can appreciate some of the power of cucumber here. There also exist some extensions to
                cucumber, one I've used personally is Aruba
            </p>
        </aside>
        <h1>Cucumber extensions</h1>
    </section>
    <section>
        <aside class="notes">
            <p>
                Aruba is designed for building command-line apps. The smart people behind this recognised that there
                a fairly small number of common operations that you're likely to be testing when writing such an app,
                such as checking console output, checking for the existence of files, etc, so as long as your specs
                conform to their patterns, a lot of the heavy lifting has been done for you
            </p>
            <p>
                So here we see a typical scenario
            </p>
            <p>
                The text gets matched by this pre-baked Aruba step def, in particular this regex captures the filename
                and passes it into the block, which hands it off to this check_file_presence method
            </p>
            <p>
                And then the actual work is done by this pure-Ruby method inside Aruba
            </p>
            <p>
                There are other cucumber extensions such as cucumber-rails which do similar things
            </p>
            <p>
                This is relevant in the context of cucumber-chef, which we'll get to in a bit
            </p>
        </aside>
        <h1>Aruba</h1>
        <h4>Pre-baked step definitions (and some other stuff)</h4>

        <pre><code data-trim class="gherkin fragment">Scenario: one without postcodes
  When I successfully run `noodile sample.csv`
  Then a file named "outputs/complete.no.postcodes.csv" should exist</code></pre>

        <pre><code data-trim class="step_definitions fragment">Then /^a file named "([^"]*)" should exist$/ do |file|
  check_file_presence([file], true)
end</code></pre>

        <pre><code data-trim class="fragment">def check_file_presence(paths, expect_presence)
  prep_for_fs_check do
    paths.each do |path|
      if expect_presence
        File.should be_file(path)
      else
        File.should_not be_file(path)
      end
    end
  end
end</code></pre>

        <small><a href="https://github.com/cucumber/aruba">https://github.com/cucumber/aruba</a></small>
    </section>
</section>
<section id="what_is_chef">
    <section data-background="identical-repeatable-disposable/robot.jpg">
        <aside class="notes">
            <p>
                So, enter the robots
            </p>
        </aside>
        <h1>Robot-powered Infrastructure</h1>
        <blockquote>All watched over by machines of loving grace</blockquote>
        <small>Richard Brautigan</small>
        <div class="photo-credit">
            <a href="http://www.flickr.com/photos/t0msk/3148160756/lightbox/">Robot</a> by
            <a href="http://www.flickr.com/photos/t0msk/">t0msk</a>
            <a href="http://creativecommons.org/licenses/by-nc-sa/2.0/">(CC BY-NC-SA 2.0)</a>
        </div>
    </section>
    <section>
        <aside class="notes">
            <p>
                First, let us take a step back and look at how we used to do this stuff. We'd order servers from Compaq
                or somebody, wait two weeks for them to arrive, take them down to the datacentre and rack them, then
                install the OS and everything else by hand following whatever unmaintained documentation you had from
                last time, and only find out which steps you'd forgotten or what you'd screwed up when it started
                exploding
            </p>
            <p>
                Or maybe you had some brittle, lashed-together shell scripts, but things like that get out of date real
                quick
            </p>
            <p>
               What you've got here is a SNOWFLAKE
            </p>
        </aside>
        <h1>Things used to suck</h1>
        <ul>
            <li>
                Physical iron, in a datacentre, with everything hand-installed
            </li>
            <li>
                Crappy documentation (if you were lucky)
            </li>
            <li>
                Maybe some hacky bash scripts
            </li>
            <li class="fragment">
                SNOWFLAKE!
            </li>
        </ul>
    </section>
    <section data-background="identical-repeatable-disposable/cows.jpg">
        <aside class="notes">
            <p>
                If you recall, the title of this talk is
            </p>
            <ul>
                <li>
                    Identical
                </li>
                <li>
                    Repeatable
                </li>
                <li>
                    Disposable
                </li>
            </ul>
            <p>
                These are all very desirable aims. The snowflake server I've just described ticks none of these boxes.
                If that server ever died, it would be very difficult it rebuild it. If it's been up for a long time and
                is in a remote DC, chances are people are scared to even reboot it - I have root on a box that has an
                uptime of more than three and a half years and it's a monumental snowflake
            </p>
        </aside>
        <h1>Treat your servers as cattle, not as pets</h1>

        <h2 class="fragment"><em>Identical</em></h2>
        <h2 class="fragment"><em>Repeatable</em></h2>
        <h2 class="fragment"><em>Disposable</em></h2>
        <div class="photo-credit">
            <a href="http://www.flickr.com/photos/pikesley/2879361159/lightbox/">Cows</a> by
            <a href="http://www.flickr.com/photos/pikesley/">pikesley</a>
            <a href="http://creativecommons.org/licenses/by-nc-sa/2.0/">(CC BY-NC-SA 2.0)</a>
        </div>
    </section>
    <section>
        <aside class="notes">
            <p>
                So what do we do now? Well, now we have configuration-management tools. My weapon of choice is Chef
            </p>

            <p>
                Using Chef, we can describe our infrastructure using a very nice Ruby Domain-Specific-Language, and
                Chef will attempt to converge our servers towards that goal
            </p>

            <p>
                Chef is based around a few key concepts - this is of necessity a bit hand-wavy:
            </p>
            <ul>
                <li>
                    Nodes which are the servers we're configuring
                </li>
                <li>
                    Recipes which contain the DSL instructions
                </li>
                <li>
                    Roles which contain a list of recipes (or other roles) and some other configuration stuff
                </li>
                <li>
                    Environments such as production, staging, QA etc
                </li>
                <li>
                    Data bags where we can store common configuration stuff
                </li>
                <li>
                    Knife, the command-line tool which drives the whole thing
                </li>
            </ul>
        </aside>
        <h1>Chef</h1>
        <ul>
            <li>
                Infrastructure as code
            </li>
            <li>
                Describe your (desired) infrastructure with a Ruby DSL
            </li>
            <li>
                Key concepts
                <ul>
                    <li>
                        <em>Nodes</em>
                    </li>
                    <li>
                        <em>Recipes</em> which are contained inside <em>cookbooks</em>
                    </li>
                    <li>
                        <em>Roles</em>
                    </li>
                    <li>
                        <em>Environments</em>
                    </li>
                    <li>
                        <em>Data bags</em>
                    </li>
                    <li>
                        <em>Knife</em>, the command-line tool which drives it all
                    </li>
                </ul>
            </li>
        </ul>
        <small><a href="http://www.opscode.com/chef/">http://www.opscode.com/chef/</a></small>
    </section>
    <section>
        <aside class="notes">
            <p>
                So let's look at a very simple section of a cookbook - this installs stock nginx using whatever the
                underlying package manager is for the current OS. It might be apt, it might be yum, it might build it
                from the FreeBSD ports tree, it doesn't matter. This is extremely portable
            </p>
        </aside>
        <h1>Simple abstractions</h1>

        <p>
            For example, this:
        </p>
        <pre><code data-trim class="chef">package 'nginx' do
  action :install
end</code></pre>
        <p>
            installs stock nginx. Under the hood, Chef works out from the host OS whether it needs <em>apt</em> or
            <em>yum</em> or whatever, but we don't need to care about that
        </p>
    </section>
    <section>
        <aside class="notes">
            <p>
                We also get idempotency, at least if we're using the built-in resources. Idempotency is a concept that
                comes from maths - an operation is idempotent if it produces the same results if executed once or more
                than once. If we think back to whatever hacky provisioning scripts we had back in the bad old days, there's a fair chance that those weren't safe to run more than once, so if they crapped out halfway through, you'd be pretty screwed
            </p>
            <p>
                But we're also free to do pretty much whatever we want...
            </p>
        </aside>
        <h1>Elegant idempotency</h1>
        <ul>
            <li>
                <a href="http://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning">Wikipedia says</a> "In
                computer science, the term idempotent is used... to describe an operation that will produce the
                same results if executed once or multiple times"
            </li>
            <li>
                OpsCode's resources (e.g. <em>package</em>) are guaranteed to be idempotent
            </li>
            <li class="fragment">
                But we can also cast aside the safety net and dive right in...
            </li>
          </ul>
    </section>
    <section>
        <aside class="notes">
            <p>
                This is just a shell script wrapped in a Chef resource. This is potentially very dangerous, there's
                nothing stopping us placing a forkbomb in there
            </p>

            <p>
                However, this is how many people start out with Chef - wrap a tiny piece of one of your existing scripts
                in a Chef resource and learn to trust it
            </p>
        </aside>
        <h1>Raw scripts</h1>
        <pre><code data-trim class="chef">script 'Bundling the gems' do
  interpreter 'bash'
  cwd current_release_directory
  user running_deploy_user
  code <<-EOF
  bundle install --without=development --quiet --path #{bundler_depot}
  EOF
end</code></pre>
        <ul>
            <li>
                This is valid Chef
            </li>
            <li>
                No guarantees here - you're on your own
            </li>
            <li class="fragment">
                There's nothing to stop you putting <pre><code class="bash">:(){ :|:& };:</code></pre> in there <em>(DON'T DO
                THIS!)</em>
            </li>
            <li class="fragment">
                This might be a good way in if you're wanting to try out Chef
            </li>
        </ul>
    </section>
</section>
<section id="test-driven_infrastructure">
    <section>
        <aside class="notes">
            <p>
                So we can do behaviour-driven development with Cucumber, and infrastructure-as-code with Chef. Can you see where we're heading with this?
            </p>
        </aside>
        <h1>Test-driven Infrastructure</h1>
    </section>
    <section>
        <aside class="notes">
            <p>
                Yes, inevitably, we have cucumber-chef. We get a test-lab, which we can spin up on VirtualBox under
                Vagrant (previous versions of cuke-chef only worked on AWS). This gives us a Chef server, the same as we
                would have in our real infrastructure. It's also got all the plumbing necessary to spin up ephemeral
                Linux instances using LXC, and, like with Aruba, some domain-specific step definitions
            </p>
            <p>
                We can examine these pieces one at a time
            </p>
        </aside>
        <h1>
            Cucumber-chef
        </h1>
        <ul>
            <li>
                Test lab
                <ul>
                    <li>
                        Chef server
                    </li>
                    <li>
                        LXC test instances
                    </li>
                </ul>
            </li>
            <li>
                Set of cucumber step definitions
            </li>
        </ul>
    </section>
    <section>
        <aside class="notes">
            <p>
                The Chef server is the central piece of a Chef setup, everything goes through this
            </p>
        </aside>
        <h1>The Chef server</h1>
        <img src="identical-repeatable-disposable/chef-server.jpg" />
    </section>
    <section>
        <h1>LXC</h1>
        <ul>
            <li>
                <a href="http://en.wikipedia.org/wiki/LXC">Wikipedia says</a>: <em>"LXC (LinuX Containers) is an
                operating system-level virtualization method for running multiple isolated Linux systems (containers) on
                a single control host."</em>
            </li>
            <li>
                This is what Heroku uses
            </li>
            <li>
                Docker is also based on LXC
            </li>
        </ul>
    </section>
</section>

{% include odi_tech_team.html %}
